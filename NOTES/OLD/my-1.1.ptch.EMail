Hello,

The following patch fixes a number of issues relating to multisort:

    * Fixed sort bug that incorrectly sorts
      01/Feb/2001:03:26:15 before 31/Jan/2001:23:25:08
    * Fixed bugs related to very old dates and dates far in the future.
    * Fixed bugs related to processing empty input files.
    * Correctly distinguish between file EOF and read errors.
    * Allow multisort to just process a single file.
    * Slightly better sanity checks on timestamp string formats.

Enjoy.

chongo (Landon Curt Noll) /\oo/\

=-=

*** multisort.c.init	Fri Nov 23 02:14:06 2001
--- multisort.c	Fri Nov 23 03:53:51 2001
***************
*** 42,48 ****
          int enabled;
          char *name;
          FILE *in_fh;
!         long atime;
          char buf[BUFSIZ + 1];
  };
  
--- 42,48 ----
          int enabled;
          char *name;
          FILE *in_fh;
!         long long atime;
          char buf[BUFSIZ + 1];
  };
  
***************
*** 53,58 ****
--- 53,73 ----
  /* Command-line: gperf -t -k* -L ANSI-C  */
  struct month { char *name; int pos; };
  
+ long long month_offset[12] = { 
+ 	0,   /* Jan */
+ 	31,  /* Feb */
+ 	59,  /* Mar */
+ 	90,  /* Apr */
+ 	120, /* May */
+ 	151, /* Jun */
+ 	181, /* Jul */
+ 	212, /* Aug */
+ 	243, /* Sep */
+ 	273, /* Oct */
+ 	304, /* Nov */
+ 	334  /* Dec */
+ };
+ 
  #define TOTAL_KEYWORDS 12
  #define MIN_WORD_LENGTH 3
  #define MAX_WORD_LENGTH 3
***************
*** 181,189 ****
   *  Ok, for this new update, don't be so bloody slack about not checking
   *  return values and string lengths and such. Lazy bastard.
   *
   */
                     
! long
  conv_time(char *s)
  {
          char *ptr;
--- 196,207 ----
   *  Ok, for this new update, don't be so bloody slack about not checking
   *  return values and string lengths and such. Lazy bastard.
   *
+  *  Return POSIX "Seconds since the Epoch" with th extension that a
+  *  long long (64 bit) value is returned and the 100/400 year leapyear
+  *  rule.
   */
                     
! long long
  conv_time(char *s)
  {
          char *ptr;
***************
*** 208,213 ****
--- 226,240 ----
                  return 0;
  
          orig_ptr = ptr;
+         if (ptr[2] != '/' ||
+ 	    ptr[6] != '/' ||
+ 	    ptr[11] != ':' ||
+ 	    ptr[14] != ':' ||
+ 	    ptr[17] != ':' ||
+ 	    ptr[20] != ' ') {
+ 	    /* malformed date string */
+ 	    return 0;
+ 	}
          ptr[2] = '\0';
          ptr[6] = '\0';
          ptr[11] = '\0';
***************
*** 227,233 ****
  
  
          ptr += 4;
!         year = atoi(ptr) - 1990;
          
          ptr += 5;
          hour = atoi(ptr);
--- 254,260 ----
  
  
          ptr += 4;
!         year = atoi(ptr) - 1900;
          
          ptr += 5;
          hour = atoi(ptr);
***************
*** 249,260 ****
          ptr[17] = ':';
          ptr[20] = ' ';
  
!         return((year * 31104000)
!                + (mon * 2592000)
!                + (mday * 86400)
!                + (hour * 3600)
!                + (min * 60) 
!                + sec);
  }
  
  
--- 276,287 ----
          ptr[17] = ':';
          ptr[20] = ' ';
  
! 	return (sec + (min * 60LL) + (hour * 3600LL) +	    /* sec of day */
! 		((month_offset[mon]+mday) * 86400LL) +	    /* day of year */
! 		((year-70) * 31536000LL) +		    /* Epoch year */
! 		(((year-69)/4) * 86400LL) - 		    /* leap days */
! 		(((year-100)/100) * 86400LL) +		    /* 100yr rule */
! 		(((year-100)/400) * 86400LL));		    /* 400yr rule */
  }
  
  
***************
*** 279,289 ****
          int if_count 		= 0;	/* number of total input files */
          int if_nr		= 0;	/* number of active input files */
          char *ret 		= NULL;
!         long min_time		= 0;
          int min_index		= 0;
          int i, j;
          
!         if (argc < 3) {
                  usage();
          }
  
--- 306,316 ----
          int if_count 		= 0;	/* number of total input files */
          int if_nr		= 0;	/* number of active input files */
          char *ret 		= NULL;
!         long long min_time	= 0LL;
          int min_index		= 0;
          int i, j;
          
!         if (argc < 2) {
                  usage();
          }
  
***************
*** 314,332 ****
  
                  /* Read the first line for each open file */
                  ret = fgets(if_list[j]->buf, BUFSIZ, if_list[j]->in_fh);
!                 if (ret == NULL) {
!                         fprintf(stderr, "multisort: empty input file `%s'",
!                                 if_list[j]->name);
!                         exit(1);
                  }
! 
          }
  
!         if_count = if_nr = j;
! 
!         while (if_nr) {
                  min_index = 0;
!                 min_time = 900000000L;
                  for (i = 0; i < if_count; i++) {
                          if (!if_list[i]->enabled)
                                  continue;
--- 341,362 ----
  
                  /* Read the first line for each open file */
                  ret = fgets(if_list[j]->buf, BUFSIZ, if_list[j]->in_fh);
! 		if (ret == NULL) {
! 			if (ferror(if_list[j]->in_fh)) {
! 				fprintf(stderr,
! 				    "multisort: read error, file `%s'",
! 				    if_list[j]->name);
! 			}
! 			fclose(if_list[j]->in_fh);
! 			if_list[j]->enabled = 0;
                  }
! 		++if_count;
! 		++if_nr;
          }
  
!         while (if_nr > 0) {
                  min_index = 0;
!                 min_time = 9223372036854775807LL;
                  for (i = 0; i < if_count; i++) {
                          if (!if_list[i]->enabled)
                                  continue;
***************
*** 343,354 ****
                  fputs(if_list[min_index]->buf, stdout);
  
                  /* refill the buffer */
!                 ret = fgets(if_list[min_index]->buf, BUFSIZ,
!                             if_list[min_index]->in_fh);
!                 if (ret == NULL) {
!                         if_list[min_index]->enabled = 0;
!                         fclose(if_list[min_index]->in_fh);
!                         if_nr--;
                  }
          }
  
--- 373,391 ----
                  fputs(if_list[min_index]->buf, stdout);
  
                  /* refill the buffer */
! 		if (if_list[min_index]->enabled) {
! 			ret = fgets(if_list[min_index]->buf, BUFSIZ,
! 				    if_list[min_index]->in_fh);
! 			if (ret == NULL) {
! 				if (ferror(if_list[min_index]->in_fh)) {
! 					fprintf(stderr,
! 					    "multisort: fgets error, file `%s'",
! 					    if_list[min_index]->name);
! 				}
! 				if_list[min_index]->enabled = 0;
! 				fclose(if_list[min_index]->in_fh);
! 				if_nr--;
! 			}
                  }
          }
  
